{"ast":null,"code":"import { EventEmitter, Directive, ElementRef, Renderer2, Inject, PLATFORM_ID, Input, Output, NgModule } from '@angular/core';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil, throttleTime, map, pairwise, distinctUntilChanged, share, filter } from 'rxjs/operators';\nimport { isPlatformServer } from '@angular/common'; // Inspired by: https://netbasal.com/reactive-sticky-header-in-angular-12dbffb3f1d3\n\n/**\r\n * The `ngxHideOnScroll` directive allows you to hide an html element (e.g. navbar) on scroll down and show it again on scroll up.\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\nlet NgxHideOnScrollDirective = /*#__PURE__*/(() => {\n  class NgxHideOnScrollDirective {\n    constructor(elementRef, renderer2, platformId) {\n      this.elementRef = elementRef;\n      this.renderer2 = renderer2;\n      this.platformId = platformId;\n      /**\r\n       * `'Down'`: The element will be hidden on scroll down and it will be shown again on scroll up.<br/>`Up`: The element will be hidden on scroll up and it will be shown again on scroll down.\r\n       */\n\n      this.hideOnScroll = 'Down';\n      /**\r\n       * CSS class name added to the element to hide it. When this property is set, `propertyUsedToHide`, `valueWhenHidden`, and `valueWhenShown` have not effect.\r\n       */\n\n      this.classNameWhenHidden = '';\n      /**\r\n       * The CSS property used to hide/show the element.\r\n       *\r\n       * @default\r\n       * 'transform'\r\n       */\n\n      this.propertyUsedToHide = 'transform';\n      /**\r\n       * The value of `propertyUsedToHide` when the element is hidden.\r\n       *\r\n       * @default\r\n       * 'translateY(-100%)'\r\n       */\n\n      this.valueWhenHidden = 'translateY(-100%)';\n      /**\r\n       * The value of `propertyUsedToHide` when the element is shown.\r\n       *\r\n       * @default\r\n       * 'translateY(0)'\r\n       */\n\n      this.valueWhenShown = 'translateY(0)';\n      /**\r\n       * The selector of the element you want to listen the scroll event, in case it is not the default browser scrolling element (`document.scrollingElement` or `document.documentElement`). For example [` .mat-sidenav-content`]( https://stackoverflow.com/a/52931772/12954396) if you are using [Angular Material Sidenav]( https://material.angular.io/components/sidenav)\r\n       */\n\n      this.scrollingElementSelector = '';\n      /**\r\n       * Emitted when the element is hidden.\r\n       */\n\n      this.eventElementHidden = new EventEmitter();\n      /**\r\n       * Emitted when the element is shown.\r\n       */\n\n      this.eventElementShown = new EventEmitter();\n      this.unsubscribeNotifier = new Subject();\n    }\n\n    ngAfterViewInit() {\n      if (isPlatformServer(this.platformId)) {\n        return;\n      }\n\n      let elementToListenScrollEvent;\n      let scrollingElement;\n\n      if (!this.scrollingElementSelector) {\n        elementToListenScrollEvent = window;\n        scrollingElement = this.getDefaultScrollingElement();\n      } else {\n        scrollingElement = document.querySelector(this.scrollingElementSelector);\n\n        if (!scrollingElement) {\n          console.error(`NgxHideOnScroll: @Input() scrollingElementSelector\\nElement with selector: \"${this.scrollingElementSelector}\" not found.`);\n          return;\n        }\n\n        elementToListenScrollEvent = scrollingElement;\n      }\n\n      const scroll$ = fromEvent(elementToListenScrollEvent, 'scroll').pipe(takeUntil(this.unsubscribeNotifier), throttleTime(50), // only emit every 50 ms\n      map(() => scrollingElement.scrollTop), // get vertical scroll position\n      pairwise(), // look at this and the last emitted element\n      // compare this and the last element to figure out scrolling direction\n      map(([y1, y2]) => y2 < y1 ? ScrollDirection.Up : ScrollDirection.Down), distinctUntilChanged(), // only emit when scrolling direction changed\n      share() // share a single subscription to the underlying sequence in case of multiple subscribers\n      );\n      const scrollUp$ = scroll$.pipe(filter(direction => direction === ScrollDirection.Up));\n      const scrollDown$ = scroll$.pipe(filter(direction => direction === ScrollDirection.Down));\n      let scrollUpAction;\n      let scrollDownAction;\n\n      if (this.hideOnScroll === 'Up') {\n        scrollUpAction = () => this.hideElement();\n\n        scrollDownAction = () => this.showElement();\n      } else {\n        scrollUpAction = () => this.showElement();\n\n        scrollDownAction = () => this.hideElement();\n      }\n\n      scrollUp$.subscribe(() => scrollUpAction());\n      scrollDown$.subscribe(() => scrollDownAction());\n    }\n\n    ngOnDestroy() {\n      this.unsubscribeNotifier.next();\n      this.unsubscribeNotifier.complete();\n    }\n\n    hideElement() {\n      const nativeElement = this.elementRef.nativeElement;\n\n      if (this.classNameWhenHidden) {\n        this.renderer2.addClass(nativeElement, this.classNameWhenHidden);\n      } else {\n        this.renderer2.setStyle(nativeElement, this.propertyUsedToHide, this.valueWhenHidden);\n      }\n\n      this.eventElementHidden.emit();\n    }\n\n    showElement() {\n      const nativeElement = this.elementRef.nativeElement;\n\n      if (this.classNameWhenHidden) {\n        this.renderer2.removeClass(nativeElement, this.classNameWhenHidden);\n      } else {\n        this.renderer2.setStyle(nativeElement, this.propertyUsedToHide, this.valueWhenShown);\n      }\n\n      this.eventElementShown.emit();\n    }\n\n    getDefaultScrollingElement() {\n      return document.scrollingElement || document.documentElement;\n    }\n\n  }\n\n  NgxHideOnScrollDirective.ɵfac = function NgxHideOnScrollDirective_Factory(t) {\n    return new (t || NgxHideOnScrollDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n\n  NgxHideOnScrollDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgxHideOnScrollDirective,\n    selectors: [[\"\", \"ngxHideOnScroll\", \"\"]],\n    inputs: {\n      hideOnScroll: \"hideOnScroll\",\n      classNameWhenHidden: \"classNameWhenHidden\",\n      propertyUsedToHide: \"propertyUsedToHide\",\n      valueWhenHidden: \"valueWhenHidden\",\n      valueWhenShown: \"valueWhenShown\",\n      scrollingElementSelector: \"scrollingElementSelector\"\n    },\n    outputs: {\n      eventElementHidden: \"eventElementHidden\",\n      eventElementShown: \"eventElementShown\"\n    }\n  });\n  return NgxHideOnScrollDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar ScrollDirection = /*#__PURE__*/(() => {\n  (function (ScrollDirection) {\n    ScrollDirection[\"Up\"] = \"Up\";\n    ScrollDirection[\"Down\"] = \"Down\";\n  })(ScrollDirection || (ScrollDirection = {}));\n\n  return ScrollDirection;\n})();\nlet NgxHideOnScrollModule = /*#__PURE__*/(() => {\n  class NgxHideOnScrollModule {}\n\n  NgxHideOnScrollModule.ɵfac = function NgxHideOnScrollModule_Factory(t) {\n    return new (t || NgxHideOnScrollModule)();\n  };\n\n  NgxHideOnScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxHideOnScrollModule\n  });\n  NgxHideOnScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return NgxHideOnScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxHideOnScrollModule, {\n    declarations: [NgxHideOnScrollDirective],\n    exports: [NgxHideOnScrollDirective]\n  });\n})();\n/*\r\n * Public API Surface of ngx-hide-on-scroll\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NgxHideOnScrollDirective, NgxHideOnScrollModule }; //# sourceMappingURL=ngx-hide-on-scroll.js.map","map":null,"metadata":{},"sourceType":"module"}